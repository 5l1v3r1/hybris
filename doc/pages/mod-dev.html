
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="it"
 lang="it" dir="ltr">

<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title></title>
<!-- metadata -->
<meta name="generator" content="Offline" />
<meta name="version" content="Offline 0.1" />
<!-- style sheet links -->
<link rel="stylesheet" media="all" type="text/css" href="../css/all.css" />
<link rel="stylesheet" media="screen" type="text/css" href="../css/screen.css" />
<link rel="stylesheet" media="print" type="text/css" href="../css/print.css" />

</head>
<body>
<div class="dokuwiki export">




<h1><a name="introduzione" id="introduzione">Introduzione</a></h1>
<div class="level1">

<p>

Come è di norma per molti altri linguaggi, la <a href="le_due_librerie_standard.html" class="wikilink1" title="le_due_librerie_standard">libreria standard</a> principale di Hybris è composta da moduli dinamici che vengono caricati dall&#039;interprete in base alla scelta dell&#039;utente, tramite la direttiva <a href="importazione.html" class="wikilink1" title="importazione">import</a>.
Questi moduli, di default<sup><a href="#fn__1" name="fnt__1" id="fnt__1" class="fn_top">1)</a></sup> vengono installati nella directory 

</p>
<pre class="code">  /usr/lib/hybris/library/
  </pre>

<p>
E seguono un alberatura di directory ben precisa, che rappresenta il loro “namespace”.
Ad esempio, il comando :
</p>
<pre class="code hybris"><span class="kw2">import</span> std<span class="sy0">.</span><span class="me1">io</span><span class="sy0">.</span><span class="me1">console</span><span class="sy0">;</span></pre>

<p>
Caricherà il modulo :

</p>
<pre class="code">  /usr/lib/hybris/library/std/io/console.so
  </pre>

<p>
e così via.
</p>

<p>
Per sviluppare un modulo, è necessaria una buona conoscenza del C/C++, un ambiente di sviluppo che soddisfi i <a href="compilazione_ed_installazione.html" class="wikilink1" title="compilazione_ed_installazione">requisiti</a> per la compilazione e la conoscenza di alcune <acronym title="Application Programming Interface">API</acronym> che il kit di sviluppo di Hybris offre .
</p>

</div>
<!-- SECTION "Introduzione" [1-982] -->
<h1><a name="modulo_hello_world" id="modulo_hello_world">Modulo Hello World</a></h1>
<div class="level1">

<p>

Andiamo ora a vedere un modulo molto semplice che esporterà la funzione <strong>say_hello</strong> .
</p>
<pre class="code cpp"><span class="co2">#include &lt;hybris.h&gt;</span>
&nbsp;
HYBRIS_DEFINE_FUNCTION<span class="br0">&#40;</span>say_hello<span class="br0">&#41;</span><span class="sy4">;</span>
&nbsp;
HYBRIS_EXPORTED_FUNCTIONS<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
	<span class="br0">&#123;</span> <span class="st0">&quot;say_hello&quot;</span>, say_hello,  H_REQ_ARGC<span class="br0">&#40;</span><span class="nu0">0</span><span class="br0">&#41;</span> <span class="br0">&#125;</span>,
	<span class="br0">&#123;</span> <span class="st0">&quot;&quot;</span>, <span class="kw2">NULL</span> <span class="br0">&#125;</span>
<span class="br0">&#125;</span><span class="sy4">;</span>
&nbsp;
HYBRIS_DEFINE_FUNCTION<span class="br0">&#40;</span>say_hello<span class="br0">&#41;</span><span class="br0">&#123;</span>
    <span class="kw3">printf</span><span class="br0">&#40;</span> <span class="st0">&quot;Hello world from my first Hybris module!<span class="es1">\n</span>&quot;</span> <span class="br0">&#41;</span><span class="sy4">;</span>
&nbsp;
    <span class="kw1">return</span> H_DEFAULT_RETURN<span class="sy4">;</span>
<span class="br0">&#125;</span></pre>

<p>
Analiziamo i vari elementi che compongono il modulo.
</p>
<pre class="code cpp"><span class="co2">#include &lt;hybris.h&gt;</span></pre>

<p>
Con questa direttiva includiamo l&#039;header hybris.h necessario per poter utilizzare le <acronym title="Application Programming Interface">API</acronym> del kit di sviluppo dei moduli.
</p>
<pre class="code cpp">HYBRIS_DEFINE_FUNCTION<span class="br0">&#40;</span>say_hello<span class="br0">&#41;</span><span class="sy4">;</span></pre>

<p>
Dichiariamo con questa macro, il prototipo della funzione che vogliamo esportare.
</p>
<pre class="code cpp">HYBRIS_EXPORTED_FUNCTIONS<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
	<span class="br0">&#123;</span> <span class="st0">&quot;say_hello&quot;</span>, say_hello, H_REQ_ARGC<span class="br0">&#40;</span><span class="nu0">0</span><span class="br0">&#41;</span> <span class="br0">&#125;</span>,
	<span class="br0">&#123;</span> <span class="st0">&quot;&quot;</span>, <span class="kw2">NULL</span> <span class="br0">&#125;</span>
<span class="br0">&#125;</span><span class="sy4">;</span></pre>

<p>
Questa lista contiene la descrizione vera e propria della funzione che stiamo esportando :

</p>
<ul>
<li class="level1"><div class="li"> “say_hello” è il nome che la funzione avrà all&#039;interno di uno script Hybris.</div>
</li>
<li class="level1"><div class="li"> say_hello è il puntatore alla funzione nel modulo, della quale abbiamo appena dichiarato il prototipo con la macro HYBRIS_DEFINE_FUNCTION.</div>
</li>
<li class="level1"><div class="li"> H_REQ_ARGC(0) indica che la funzione non richiede nessun (zero) parametro.</div>
</li>
<li class="level1"><div class="li"> { ””, NULL } termina la lista, va <strong>sempre</strong> inserito alla fine della lista delle funzioni come terminatore.</div>
</li>
</ul>
<pre class="code cpp">HYBRIS_DEFINE_FUNCTION<span class="br0">&#40;</span>say_hello<span class="br0">&#41;</span><span class="br0">&#123;</span>
    <span class="kw3">printf</span><span class="br0">&#40;</span> <span class="st0">&quot;Hello world from my first Hybris module!<span class="es1">\n</span>&quot;</span> <span class="br0">&#41;</span><span class="sy4">;</span>
&nbsp;
    <span class="kw1">return</span> H_DEFAULT_RETURN<span class="sy4">;</span>
<span class="br0">&#125;</span></pre>

<p>
Questa è la funzione vera e propria, che stamperà il messaggio “Hello world from my first Hybris module!”.
Ogni funzione <strong>deve</strong> restituire un valore quindi, in questo caso, utiliziamo la macro H_DEFAULT_RETURN ad indicare che stiamo restituendo un valore di default non dovendo restituire nulla in particolare.
</p>

</div>
<!-- SECTION "Modulo Hello World" [983-2835] -->
<h1><a name="compilazione" id="compilazione">Compilazione</a></h1>
<div class="level1">

<p>

Per compilare il modulo appena creato, utilizzeremo i seguenti comandi :
</p>
<pre class="code bash"><span class="kw2">g++</span> <span class="re5">-c</span> <span class="re5">-export-dynamic</span> <span class="re5">-fPIC</span> hello.cpp
<span class="kw2">g++</span> <span class="re5">-shared</span> <span class="re5">-lc</span> <span class="re5">-o</span> hello.so hello.o <span class="re5">-lhybris</span></pre>

<p>
Dove :

</p>
<ul>
<li class="level1"><div class="li"> hello.cpp è il nome del sorgente del modulo.</div>
</li>
<li class="level1"><div class="li"> hello.o è il file intermedio che viene generato durante la compilazione</div>
</li>
<li class="level1"><div class="li"> hello.so è il nome finale che avrà il modulo</div>
</li>
</ul>

</div>
<!-- SECTION "Compilazione" [2836-3229] -->
<h1><a name="installazione" id="installazione">Installazione</a></h1>
<div class="level1">

<p>

Per installare un modulo, bisogna prima decidere il suo namespace, ovvero in quale alberatura di directory si troverà e di conseguenza quali namespace passare alla direttiva import per caricarlo.
Nel nostro caso, ipotiziamo il namespace “test”, di conseguenza il file del modulo andrà copiato in :

</p>
<pre class="code">  /usr/lib/hybris/library/test/hello.so
  </pre>

<p>
E potrà essere richiamato ed usato come nel seguente esempio :
</p>
<pre class="code hybris"><span class="kw2">import</span> test<span class="sy0">.</span><span class="me1">hello</span><span class="sy0">;</span>
&nbsp;
say_hello<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span></pre>
<pre class="code">  Hello world from my first Hybris module!
  </pre>

</div>
<!-- SECTION "Installazione" [3230-3779] -->
<h1><a name="modulo_math" id="modulo_math">Modulo Math</a></h1>
<div class="level1">

<p>

Nel precedente modulo, abbiamo considerato una semplice funzione che non accetta argomenti in ingresso, ne restituisce alcun valore (se non quello di default) in output.
Consideriamo ora un esempio più elaborato, un modulo “math” che esporta la funzione “add” la quale eseguirà l&#039;addizione tra due numeri e ne restituirà il risultato.
In questo caso la funzione, accettando due parametri, deve essere impostata per accettare anche due tipologie diverse (delle quali parleremo in un paragrafo successivo) per ogni parametro, ovvero ognuno dei due parametri potrà essere o un <a href="intero.html" class="wikilink1" title="intero">numero intero</a> o un <a href="reale.html" class="wikilink1" title="reale">numero reale</a>.
</p>
<pre class="code cpp"><span class="co2">#include &lt;hybris.h&gt;</span>
&nbsp;
HYBRIS_DEFINE_FUNCTION<span class="br0">&#40;</span>add<span class="br0">&#41;</span><span class="sy4">;</span>
&nbsp;
HYBRIS_EXPORTED_FUNCTIONS<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
	<span class="br0">&#123;</span> <span class="st0">&quot;add&quot;</span>, add,  H_REQ_ARGC<span class="br0">&#40;</span><span class="nu0">2</span><span class="br0">&#41;</span>, <span class="br0">&#123;</span> H_REQ_TYPES<span class="br0">&#40;</span> otInteger, otFloat <span class="br0">&#41;</span>, H_REQ_TYPES<span class="br0">&#40;</span> otInteger, otFloat <span class="br0">&#41;</span> <span class="br0">&#125;</span> <span class="br0">&#125;</span>,
	<span class="br0">&#123;</span> <span class="st0">&quot;&quot;</span>, <span class="kw2">NULL</span> <span class="br0">&#125;</span>
<span class="br0">&#125;</span><span class="sy4">;</span>
&nbsp;
HYBRIS_DEFINE_FUNCTION<span class="br0">&#40;</span>add<span class="br0">&#41;</span><span class="br0">&#123;</span>
	<span class="co1">// prendo gli argomenti passati alla funzione dallo script    </span>
	Object <span class="sy2">*</span>arg_0,
		   <span class="sy2">*</span>arg_1<span class="sy4">;</span>
&nbsp;
	arg_0 <span class="sy1">=</span> ob_argv<span class="br0">&#40;</span>0<span class="br0">&#41;</span><span class="sy4">;</span>
	arg_1 <span class="sy1">=</span> ob_argv<span class="br0">&#40;</span>1<span class="br0">&#41;</span><span class="sy4">;</span>
&nbsp;
	<span class="co1">// prelevo il valore double dai due argomenti, in base alla loro</span>
	<span class="co1">// tipologia</span>
	<span class="kw4">double</span> a, b<span class="sy4">;</span>
&nbsp;
	<span class="kw1">if</span><span class="br0">&#40;</span> ob_is_int<span class="br0">&#40;</span> arg_0<span class="br0">&#41;</span> <span class="br0">&#41;</span><span class="br0">&#123;</span>
        a <span class="sy1">=</span> <span class="br0">&#40;</span><span class="kw4">double</span><span class="br0">&#41;</span>ob_int_val<span class="br0">&#40;</span> arg_0 <span class="br0">&#41;</span><span class="sy4">;</span>
    <span class="br0">&#125;</span>
    <span class="kw1">else</span><span class="br0">&#123;</span>
        a <span class="sy1">=</span> ob_float_val<span class="br0">&#40;</span> arg_0 <span class="br0">&#41;</span><span class="sy4">;</span>
    <span class="br0">&#125;</span>
&nbsp;
    <span class="kw1">if</span><span class="br0">&#40;</span> ob_is_int<span class="br0">&#40;</span> arg_1 <span class="br0">&#41;</span> <span class="br0">&#41;</span><span class="br0">&#123;</span>
        b <span class="sy1">=</span> <span class="br0">&#40;</span><span class="kw4">double</span><span class="br0">&#41;</span>ob_int_val<span class="br0">&#40;</span> arg_1 <span class="br0">&#41;</span><span class="sy4">;</span>
    <span class="br0">&#125;</span>
    <span class="kw1">else</span><span class="br0">&#123;</span>
        b <span class="sy1">=</span> ob_float_val<span class="br0">&#40;</span> arg_1 <span class="br0">&#41;</span><span class="sy4">;</span>
    <span class="br0">&#125;</span>
&nbsp;
	<span class="co1">// eseguo la somma e restituisco un numero reale come risultato</span>
    <span class="kw1">return</span> <span class="br0">&#40;</span>Object <span class="sy2">*</span><span class="br0">&#41;</span>gc_new_float<span class="br0">&#40;</span> a <span class="sy2">+</span> b <span class="br0">&#41;</span><span class="sy4">;</span>
<span class="br0">&#125;</span></pre>

<p>
Come è possibile vedere, l&#039;esempio è leggermente diverso dal modulo precedente, andiamo ad analizzare le differenze principali .
</p>
<pre class="code cpp"><span class="br0">&#123;</span> <span class="st0">&quot;add&quot;</span>, add,  H_REQ_ARGC<span class="br0">&#40;</span><span class="nu0">2</span><span class="br0">&#41;</span>, <span class="br0">&#123;</span> H_REQ_TYPES<span class="br0">&#40;</span> otInteger, otFloat <span class="br0">&#41;</span>, H_REQ_TYPES<span class="br0">&#40;</span> otInteger, otFloat <span class="br0">&#41;</span> <span class="br0">&#125;</span> <span class="br0">&#125;</span></pre>

<p>
Mentre prima utilizzavamo H_REQ_ARGC(0) e basta, poichè la funzione non richiedeva dei parametri in ingresso, questa volta la funzione richiede due parametri in ingresso ( H_REQ_ARGC(2) ), ognuno dei quali può rispettivamente essere un numero intero o un numero reale H_REQ_TYPES( otInteger, otFloat ) .
</p>
<pre class="code">
// prendo gli argomenti passati alla funzione dallo script    
Object *arg_0,
       *arg_1;

arg_0 = vm_argv(0);
arg_1 = vm_argv(1);
</pre>

<p>
Ogni oggetto di Hybris, è rappresentato dalla struttura “Object” (definita nel file <a href="http://github.com/evilsocket/hybris/blob/master/include/types.h" class="urlextern" title="http://github.com/evilsocket/hybris/blob/master/include/types.h"  rel="nofollow">types.h</a>) che naturalmente non può essere direttamente usato come un tipo C/C++.
In questo blocco di codice, tramite la macro <strong>vm_argv( n )</strong> dove <strong>n</strong> rappresenta l&#039;n-esimo argomento della funzione che ci interessa, preleviamo i due argomenti della funzione <strong>add</strong> e li mettiamo dentro le variabili arg_0 (il primo argomento) e arg_1 (il secondo).
</p>
<pre class="code cpp"><span class="co1">// prelevo il valore double dai due argomenti, in base alla loro</span>
<span class="co1">// tipologia</span>
<span class="kw4">double</span> a, b<span class="sy4">;</span>
&nbsp;
<span class="kw1">if</span><span class="br0">&#40;</span> ob_is_int<span class="br0">&#40;</span> arg_0<span class="br0">&#41;</span> <span class="br0">&#41;</span><span class="br0">&#123;</span>
    a <span class="sy1">=</span> <span class="br0">&#40;</span><span class="kw4">double</span><span class="br0">&#41;</span>ob_int_val<span class="br0">&#40;</span> arg_0 <span class="br0">&#41;</span><span class="sy4">;</span>
<span class="br0">&#125;</span>
<span class="kw1">else</span><span class="br0">&#123;</span>
    a <span class="sy1">=</span> ob_float_val<span class="br0">&#40;</span> arg_0 <span class="br0">&#41;</span><span class="sy4">;</span>
<span class="br0">&#125;</span>
&nbsp;
<span class="kw1">if</span><span class="br0">&#40;</span> ob_is_int<span class="br0">&#40;</span> arg_1 <span class="br0">&#41;</span> <span class="br0">&#41;</span><span class="br0">&#123;</span>
    b <span class="sy1">=</span> <span class="br0">&#40;</span><span class="kw4">double</span><span class="br0">&#41;</span>ob_int_val<span class="br0">&#40;</span> arg_1 <span class="br0">&#41;</span><span class="sy4">;</span>
<span class="br0">&#125;</span>
<span class="kw1">else</span><span class="br0">&#123;</span>
    b <span class="sy1">=</span> ob_float_val<span class="br0">&#40;</span> arg_1 <span class="br0">&#41;</span><span class="sy4">;</span>
<span class="br0">&#125;</span></pre>

<p>
Qui invece eseguiamo la trasformazione da struttura Object ad una variabile di tipologia double, quindi compatibile con il C/C++, per effettuare comodamente la nostra addizione.
Dal momento che ognuno degli argomenti può essere sia un intero che un numero reale, utiliziamo la macro <strong>ob_is_int</strong> per determinare se il numero è intero, ed in tal caso ne preleviamo il valore <strong>int</strong> tramite la macro <strong>ob_int_val</strong> e lo castiamo a double.
Viceversa, se la variabile è di tipo reale (quindi ob_is_int restituirà false), preleviamo direttamente il suo valore tramite la macro <strong>ob_float_val</strong>.
A questo punto, abbiamo i valori double dentro le variabili <strong>a</strong> e <strong>b</strong> e possiamo procedere ad effettuare l&#039;addizione e a restituire un oggetto reale.
</p>
<pre class="code">return (Object *)gc_new_float( a + b );</pre>

<p>
Il cast ad “Object *” è necessario poichè, a prescindere dalla sua tipologia (reale, intero, stringa, ecc), il valore di ritorno di ogni funzione deve essere riportato ad una tipologia base comune, appunto la struttura Object.
La macro <strong>gc_new_float</strong> richiederà al <a href="gestione_della_memoria.html" class="wikilink1" title="gestione_della_memoria">garbage collector</a> di creare un nuovo oggetto di tipo reale, inizializzandolo con il valore della somma “a + b”.
</p>

</div>
<!-- SECTION "Modulo Math" [3780-8047] -->
<h1><a name="inizializzazione_di_un_modulo" id="inizializzazione_di_un_modulo">Inizializzazione di un Modulo</a></h1>
<div class="level1">

<p>

Se il modulo avesse la necessità di eseguire determinate operazioni, ad esempio inizializzare delle variabili globali, durante la fase di caricamento, deve esportare la funzione <strong>hybris_module_init</strong> nel seguente modo :
</p>
<pre class="code cpp"><span class="kw4">extern</span> <span class="st0">&quot;C&quot;</span> <span class="kw4">void</span> hybris_module_init<span class="br0">&#40;</span> vm_t <span class="sy2">*</span> vm <span class="br0">&#41;</span><span class="br0">&#123;</span>
    <span class="kw3">printf</span><span class="br0">&#40;</span> <span class="st0">&quot;Hello World!<span class="es1">\n</span>&quot;</span> <span class="br0">&#41;</span><span class="sy4">;</span>
<span class="br0">&#125;</span></pre>

<p>
La struttura vm_t identifica un istanza alla virtual machine stessa e non va assolutamente toccata, a meno che non si è perfettamente consapevoli di cosa si sta facendo.
Se esportata quindi, questa funzione verrà eseguita all&#039;avvio del modulo.
</p>

</div>
<!-- SECTION "Inizializzazione di un Modulo" [8048-8665] -->
<h1><a name="definizione_di_costanti" id="definizione_di_costanti">Definizione di Costanti</a></h1>
<div class="level1">

<p>

Se il modulo avesse la necessità di definire alcune variabili costanti (che quindi sono visibili globalmente nello script e che non possono essere modificate), come ad esempio, nel caso del modulo math precedentemente analizzato, il valore del pi greco, può usare la macro <strong>HYBRIS_DEFINE_CONSTANT</strong> all&#039;interno della funzione di inizializzazione appena vista, come ad esempio :
</p>
<pre class="code cpp"><span class="kw4">extern</span> <span class="st0">&quot;C&quot;</span> <span class="kw4">void</span> hybris_module_init<span class="br0">&#40;</span> vm_t <span class="sy2">*</span> vm <span class="br0">&#41;</span><span class="br0">&#123;</span>
    HYBRIS_DEFINE_CONSTANT<span class="br0">&#40;</span> vm, <span class="st0">&quot;PI&quot;</span>, gc_new_float<span class="br0">&#40;</span>3.14159<span class="br0">&#41;</span> <span class="br0">&#41;</span><span class="sy4">;</span>
<span class="br0">&#125;</span></pre>

<p>
Dove 

</p>
<ul>
<li class="level1"><div class="li"> vm è l&#039;istanza della virtual machine che viene passata alla funzione di inizializzazione.</div>
</li>
<li class="level1"><div class="li"> “PI” è l&#039;identificatore che dovrà essere utilizzato per accedere al valore della costante.</div>
</li>
<li class="level1"><div class="li"> gc_new_float(3.14159) crea un oggetto di tipo float inizializzandolo con il valore 3.14159. <sup><a href="#fn__2" name="fnt__2" id="fnt__2" class="fn_top">2)</a></sup></div>
</li>
</ul>

</div>
<!-- SECTION "Definizione di Costanti" [8666-9575] -->
<h1><a name="le_api_dell_sdk_di_hybris" id="le_api_dell_sdk_di_hybris">Le API dell&#039;SDK di Hybris</a></h1>
<div class="level1">

</div>
<!-- SECTION "Le API dell'SDK di Hybris" [9576-9616] -->
<h2><a name="codici_delle_tipologie" id="codici_delle_tipologie">Codici delle tipologie</a></h2>
<div class="level2">
<ul>
<li class="level1"><div class="li"> <strong>otBoolean</strong> Booleano.</div>
</li>
<li class="level1"><div class="li"> <strong>otInteger</strong> Intero.</div>
</li>
<li class="level1"><div class="li"> <strong>otFloat</strong> Reale.</div>
</li>
<li class="level1"><div class="li"> <strong>otChar</strong> Carattere.</div>
</li>
<li class="level1"><div class="li"> <strong>otString</strong> Stringa.</div>
</li>
<li class="level1"><div class="li"> <strong>otBinary</strong> Binario.</div>
</li>
<li class="level1"><div class="li"> <strong>otVector</strong> Vettore/Array.</div>
</li>
<li class="level1"><div class="li"> <strong>otMap</strong> Mappa.</div>
</li>
<li class="level1"><div class="li"> <strong>otAlias</strong> Alias.</div>
</li>
<li class="level1"><div class="li"> <strong>otExtern</strong> Extern.</div>
</li>
<li class="level1"><div class="li"> <strong>otHandle</strong> Handle.</div>
</li>
<li class="level1"><div class="li"> <strong>otStructure</strong> Struttura.</div>
</li>
<li class="level1"><div class="li"> <strong>otClass</strong> Classe.</div>
</li>
<li class="level1"><div class="li"> <strong>otReference</strong> Riferimento.</div>
</li>
</ul>

</div>
<!-- SECTION "Codici delle tipologie" [9617-10022] -->
<h2><a name="creazione_e_allocazione_di_oggetti" id="creazione_e_allocazione_di_oggetti">Creazione e allocazione di oggetti</a></h2>
<div class="level2">
<ul>
<li class="level1"><div class="li"> <strong>gc_new_boolean(v)</strong> Crea ed inizializza con il valore &#039;v&#039; un oggetto booleano.</div>
</li>
<li class="level1"><div class="li"> <strong>gc_new_integer(v)</strong> Crea ed inizializza con il valore &#039;v&#039; un numero intero.</div>
</li>
<li class="level1"><div class="li"> <strong>gc_new_alias(v)</strong> Crea ed inizializza con il valore &#039;v&#039; un oggetto alias.</div>
</li>
<li class="level1"><div class="li"> <strong>gc_new_extern(v)</strong> Crea ed inizializza con il valore &#039;v&#039; un oggetto extern.</div>
</li>
<li class="level1"><div class="li"> <strong>gc_new_float(v)</strong> Crea ed inizializza con il valore &#039;v&#039; un numero reale.</div>
</li>
<li class="level1"><div class="li"> <strong>gc_new_char(v)</strong> Crea ed inizializza con il valore &#039;v&#039; un carattere.</div>
</li>
<li class="level1"><div class="li"> <strong>gc_new_string(v)</strong> Crea ed inizializza con il valore &#039;v&#039; una stringa.</div>
</li>
<li class="level1"><div class="li"> <strong>gc_new_binary(d)</strong> Crea ed inizializza con il valore &#039;v&#039; un oggetto binary.</div>
</li>
<li class="level1"><div class="li"> <strong>gc_new_vector()</strong> Crea un vettore.</div>
</li>
<li class="level1"><div class="li"> <strong>gc_new_map()</strong> Crea una mappa.</div>
</li>
<li class="level1"><div class="li"> <strong>gc_new_struct()</strong> Crea una struttura.</div>
</li>
<li class="level1"><div class="li"> <strong>gc_new_class()</strong> Crea una classe.</div>
</li>
<li class="level1"><div class="li"> <strong>gc_new_reference(o)</strong> Crea un riferimento all&#039;oggetto &#039;o&#039;.</div>
</li>
<li class="level1"><div class="li"> <strong>gc_new_handle(p)</strong> Crea ed inizializza con il puntatore &#039;p&#039; un oggetto handle.</div>
</li>
</ul>

</div>
<!-- SECTION "Creazione e allocazione di oggetti" [10023-11024] -->
<h2><a name="controllo_dei_tipi" id="controllo_dei_tipi">Controllo dei tipi</a></h2>
<div class="level2">
<ul>
<li class="level1"><div class="li"> <strong>ob_is_boolean(o)</strong> Determina se un oggetto è booleano.</div>
</li>
<li class="level1"><div class="li"> <strong>ob_is_int(o)</strong> Determina se un oggetto è intero.</div>
</li>
<li class="level1"><div class="li"> <strong>ob_is_alias(o)</strong> Determina se un oggetto è un alias.</div>
</li>
<li class="level1"><div class="li"> <strong>ob_is_extern(o)</strong> Determina se un oggetto è un extern.</div>
</li>
<li class="level1"><div class="li"> <strong>ob_is_float(o)</strong> Determina se un oggetto è un numero reale.</div>
</li>
<li class="level1"><div class="li"> <strong>ob_is_char(o)</strong> Determina se un oggetto è un carattere.</div>
</li>
<li class="level1"><div class="li"> <strong>ob_is_string(o)</strong> Determina se un oggetto è una stringa.</div>
</li>
<li class="level1"><div class="li"> <strong>ob_is_binary(o)</strong> Determina se un oggetto è di tipo binary.</div>
</li>
<li class="level1"><div class="li"> <strong>ob_is_vector(o)</strong> Determina se un oggetto è un vettore.</div>
</li>
<li class="level1"><div class="li"> <strong>ob_is_map(o)</strong> Determina se un oggetto è una mappa.</div>
</li>
<li class="level1"><div class="li"> <strong>ob_is_struct(o)</strong> Determina se un oggetto è una struttura.</div>
</li>
<li class="level1"><div class="li"> <strong>ob_is_class(o)</strong> Determina se un oggetto è una classe.</div>
</li>
<li class="level1"><div class="li"> <strong>ob_is_reference(o)</strong> Determina se un oggetto è un riferimento.</div>
</li>
<li class="level1"><div class="li"> <strong>ob_is_handle(o)</strong> Determina se un oggetto è un handle.</div>
</li>
</ul>

</div>
<!-- SECTION "Controllo dei tipi" [11025-11940] -->
<h2><a name="api_di_elaborazione_avanzata" id="api_di_elaborazione_avanzata">API di elaborazione avanzata</a></h2>
<div class="level2">
<pre class="code cpp"><span class="kw4">bool</span> ob_is_type_in<span class="br0">&#40;</span> Object <span class="sy2">*</span>o, ... <span class="br0">&#41;</span><span class="sy4">;</span></pre>

<p>

Restituisce true se l&#039;oggetto &#039;o&#039; è di una delle tipologie specificate nei parametri successivi, altrimenti restituisce false.
</p>
<pre class="code cpp"><span class="kw4">const</span> <span class="kw4">char</span> <span class="sy2">*</span>ob_typename<span class="br0">&#40;</span> Object <span class="sy2">*</span> o <span class="br0">&#41;</span><span class="sy4">;</span></pre>

<p>

Restituisce la tipologia dell&#039;oggetto &#039;o&#039; sotto forma di stringa.
</p>
<pre class="code cpp">Object<span class="sy2">*</span> ob_clone<span class="br0">&#40;</span> Object <span class="sy2">*</span>o <span class="br0">&#41;</span><span class="sy4">;</span></pre>

<p>

Crea un clone dell&#039;oggetto &#039;o&#039;.
</p>
<pre class="code cpp"><span class="kw4">size_t</span> ob_get_size<span class="br0">&#40;</span> Object <span class="sy2">*</span>o <span class="br0">&#41;</span><span class="sy4">;</span></pre>

<p>

Restituisce la grandezza dell&#039;oggetto &#039;o&#039; o, nel caso sia una collezione, il numero degli elementi che contiene.
</p>
<pre class="code cpp"><span class="kw4">int</span> ob_cmp<span class="br0">&#40;</span> Object <span class="sy2">*</span>o, Object <span class="sy2">*</span> cmp <span class="br0">&#41;</span><span class="sy4">;</span></pre>

<p>

Esegue un confronto tra l&#039;oggetto &#039;o&#039; e &#039;cmp&#039;, restituisce :
</p>
<ul>
<li class="level1"><div class="li"> 0  se o == cmp</div>
</li>
<li class="level1"><div class="li"> 1  se o &gt; cmp</div>
</li>
<li class="level1"><div class="li"> -1 se o &lt; cmp</div>
</li>
</ul>
<pre class="code cpp"><span class="kw4">long</span> ob_ivalue<span class="br0">&#40;</span> Object <span class="sy2">*</span>o <span class="br0">&#41;</span><span class="sy4">;</span></pre>

<p>

Esegue, se possibile, il cast ad int dell&#039;oggetto e ne restituisce il valore intero.
</p>
<pre class="code cpp"><span class="kw4">double</span> ob_fvalue<span class="br0">&#40;</span> Object <span class="sy2">*</span>o <span class="br0">&#41;</span><span class="sy4">;</span></pre>

<p>

Esegue, se possibile, il cast a double dell&#039;oggetto e ne restituisce il valore double.
</p>
<pre class="code cpp"><span class="kw4">bool</span> ob_lvalue<span class="br0">&#40;</span> Object <span class="sy2">*</span>o <span class="br0">&#41;</span><span class="sy4">;</span></pre>

<p>

Restituisce la rappresentazione logica dell&#039;oggetto.
</p>
<pre class="code cpp">string ob_svalue<span class="br0">&#40;</span> Object <span class="sy2">*</span>o <span class="br0">&#41;</span><span class="sy4">;</span></pre>

<p>

Restituisce la rappresentazione sotto forma di stringa dell&#039;oggetto.
</p>
<pre class="code cpp"><span class="kw4">void</span> ob_print<span class="br0">&#40;</span> Object <span class="sy2">*</span>o, <span class="kw4">int</span> tabs <span class="sy1">=</span> 0 <span class="br0">&#41;</span><span class="sy4">;</span></pre>

<p>

Stampa l&#039;oggetto &#039;o&#039; sullo stdout, precedendolo con &#039;tabs&#039; tabulazioni.
</p>
<pre class="code cpp">Object <span class="sy2">*</span>ob_to_string<span class="br0">&#40;</span> Object <span class="sy2">*</span>o <span class="br0">&#41;</span><span class="sy4">;</span></pre>

<p>

Converte, se possibile, l&#039;oggetto &#039;o&#039; in un oggetto stringa.
</p>
<pre class="code cpp">Object <span class="sy2">*</span>ob_to_int<span class="br0">&#40;</span> Object <span class="sy2">*</span>o <span class="br0">&#41;</span><span class="sy4">;</span></pre>

<p>

Converte, se possibile, l&#039;oggetto &#039;o&#039; in un oggetto intero.
</p>
<pre class="code cpp">Object <span class="sy2">*</span>ob_cl_push<span class="br0">&#40;</span> Object <span class="sy2">*</span>a, Object <span class="sy2">*</span>b <span class="br0">&#41;</span><span class="sy4">;</span></pre>

<p>

Crea un clone di &#039;b&#039; e richiama ob_cl_push_reference per aggiungere in coda il clone alla collezione &#039;a&#039;.
</p>
<pre class="code cpp">Object <span class="sy2">*</span>ob_cl_push_reference<span class="br0">&#40;</span> Object <span class="sy2">*</span>a, Object <span class="sy2">*</span>b <span class="br0">&#41;</span><span class="sy4">;</span></pre>

<p>

Aggiunge in coda l&#039;oggetto &#039;b&#039; alla collezione &#039;a&#039;.
</p>
<pre class="code cpp">Object <span class="sy2">*</span>ob_cl_pop<span class="br0">&#40;</span> Object <span class="sy2">*</span>o <span class="br0">&#41;</span><span class="sy4">;</span></pre>

<p>

Rimuove l&#039;ultimo elemento della collezione &#039;o&#039; e lo restituisce.
</p>
<pre class="code cpp">Object <span class="sy2">*</span>ob_cl_remove<span class="br0">&#40;</span> Object <span class="sy2">*</span>a, Object <span class="sy2">*</span>b <span class="br0">&#41;</span><span class="sy4">;</span></pre>

<p>

Rimuove l&#039;elemento all&#039;indice (o chiave se una mappa) &#039;b&#039; dalla collezione &#039;a&#039;.
</p>
<pre class="code cpp">Object <span class="sy2">*</span>ob_cl_at<span class="br0">&#40;</span> Object <span class="sy2">*</span>a, Object <span class="sy2">*</span>b <span class="br0">&#41;</span><span class="sy4">;</span></pre>

<p>

Restituisce l&#039;elemento all&#039;indice (o chiave se una mappa) &#039;b&#039; dalla collezione &#039;a&#039;.
</p>
<pre class="code cpp">Object <span class="sy2">*</span>ob_cl_set<span class="br0">&#40;</span> Object <span class="sy2">*</span>a, Object <span class="sy2">*</span>b, Object <span class="sy2">*</span>c <span class="br0">&#41;</span><span class="sy4">;</span></pre>

<p>

Crea un clone di &#039;c&#039; e richiama ob_cl_set_reference( a, b, clone ) per inserire il clone
all&#039;indice/chiave &#039;b&#039; nella collezione &#039;a&#039;.
</p>
<pre class="code cpp">Object <span class="sy2">*</span>ob_cl_set_reference<span class="br0">&#40;</span> Object <span class="sy2">*</span>a, Object <span class="sy2">*</span>b, Object <span class="sy2">*</span>c <span class="br0">&#41;</span><span class="sy4">;</span></pre>

<p>

Inserisce l&#039;oggetto &#039;c&#039; all&#039;indice/chiave &#039;b&#039; dentro la collezione &#039;a&#039;.

</p>

</div>
<!-- SECTION "API di elaborazione avanzata" [11941-] --><div class="footnotes">
<div class="fn"><sup><a href="#fnt__1" id="fn__1" name="fn__1" class="fn_bot">1)</a></sup> 
Nel caso in cui non venga modificata manualmente la variabile “PREFIX” nel file di compilazione.</div>
<div class="fn"><sup><a href="#fnt__2" id="fn__2" name="fn__2" class="fn_bot">2)</a></sup> 
Vedere paragrafo sulle <acronym title="Application Programming Interface">API</acronym> di creazione degli oggetti.</div>
</div>
</div><!-- closes <div class="dokuwiki export">-->