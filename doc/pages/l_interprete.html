
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="it"
 lang="it" dir="ltr">

<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title></title>
<!-- metadata -->
<meta name="generator" content="Offline" />
<meta name="version" content="Offline 0.1" />
<!-- style sheet links -->
<link rel="stylesheet" media="all" type="text/css" href="../css/all.css" />
<link rel="stylesheet" media="screen" type="text/css" href="../css/screen.css" />
<link rel="stylesheet" media="print" type="text/css" href="../css/print.css" />

</head>
<body>
<div class="dokuwiki export">




<h1><a name="introduzione" id="introduzione">Introduzione</a></h1>
<div class="level1">

<p>

L’interprete è costituito dal file eseguibile “hybris“, di conseguenza da ora in poi con questo termine verranno indicati sia il linguaggio di per se che il software in grado di eseguirlo.
</p>

<p>
Il modo più semplice per eseguire uno script consiste nella linea di comando :

</p>
<pre class="code">hybris script.hy</pre>

<p>

Dove naturalmente “script.hy” è il file che contiene il codice da eseguire.
Ciò nonostante, se eseguiamo il comando :

</p>
<pre class="code">hybris -h </pre>

<p>

o

</p>
<pre class="code">hybris --help </pre>

<p>

Troviamo una panoramica abbastanza completa delle varie modalità di esecuzione, ovvero :

</p>
<pre class="code">Hybris versione (built: data_compilazione)
Released under GPL v3.0 by The Hybris Dev Team http://www.hybris-lang.org/
Compiled with :
  Library path : /usr/lib/hybris/library/
  Include path : /usr/lib/hybris/include/</pre>
<pre class="code">Usage: hybris &lt;options&gt; file</pre>
<pre class="code">Where &lt;options&gt; is one or more among followring values :
  -h (--help)    : Print this menu and exit.
  -m (--mem)     : Set the allocation memory limit expressed in bytes (see --gc, default is 128MB). 
  -g (--gc)      : Set the garbage collection memory threshold, expressed in bytes, 
                   kilobytes (with K postfix) or megabytes (with M postfix).
                   i.e. -g 10K or -g 1024 or --gc=100M
  -c (--cgi)     : Run in CGI mode (stderr will be redirected to stdout).
  -t (--time)    : Compute execution time and print it to stdout.
  -s (--trace)   : Enable stack trace report on errors .</pre>

</div>
<!-- SECTION "Introduzione" [1-1474] -->
<h1><a name="opzioni" id="opzioni">Opzioni</a></h1>
<div class="level1">

</div>
<!-- SECTION "Opzioni" [1475-1497] -->
<h2><a name="m_o_--mem" id="m_o_--mem">-m o --mem</a></h2>
<div class="level2">

<p>

Questo parametro imposta quanta memoria, espressa in byte, può essere utilizzata al massimo durante l&#039;esecuzione di uno script, al raggiungimento della quale l&#039;interprete terminerà l&#039;esecuzione come misura preventiva di sicurezza stampando su schermo un messaggio di errore.
</p>

<p>
Può essere specificata in byte
</p>

<p>
<code>–mem=10</code>
</p>

<p>
In kilobyte
</p>

<p>
<code>–mem=10K</code>
</p>

<p>
o in megabyte
</p>

<p>
<code>–mem=10M</code>
</p>

<p>
Se non viene passato come argomento, il valore di default di questa soglia è di <strong>128MB</strong> di memoria.
</p>

</div>
<!-- SECTION "-m o --mem" [1498-2008] -->
<h2><a name="g_o_--gc" id="g_o_--gc">-g o --gc</a></h2>
<div class="level2">

<p>

Questo parametro serve per impostare una soglia di garbage collection arbitraria (vedere sezione sulla gestione della memoria), raggiunta la quale il garbage collector inizierà il suo ciclo per liberare memoria.
</p>

<p>
Può essere specificata in byte
</p>

<p>
<code>–gc=10</code>
</p>

<p>
In kilobyte
</p>

<p>
<code>–gc=10K</code>
</p>

<p>
o in megabyte
</p>

<p>
<code>–gc=10M</code>
</p>

<p>
Più è basso questo valore, più frequentemente il garbage collector libererà memoria, quindi meno consumo di memoria ma prestazioni più basse, d&#039;altro canto se si imposta un valore molto alto, il gc verrà richiamato meno frequentemente portando a prestazioni più elevate ma ad un uso maggiore della memoria.
</p>

<p>
Se non viene passato come argomento, il valore di default di questa soglia è di circa 2MB di memoria.
</p>

</div>
<!-- SECTION "-g o --gc" [2009-2766] -->
<h2><a name="c_o_--cgi" id="c_o_--cgi">-c o --cgi</a></h2>
<div class="level2">

<p>

Questo parametro va usato quando si utilizza uno script in modalità <acronym title="Common Gateway Interface">CGI</acronym>, in modo tale da redirezionare lo standard error verso lo standard output ed eliminare eventuali byte per la colorazione degli errori dai messaggi dell&#039;interprete.
Per un riferimento dettagliato su questa modalità, consultare la <a href="cgi.html" class="wikilink1" title="cgi">sezione apposita</a>.
</p>

</div>
<!-- SECTION "-c o --cgi" [2767-3120] -->
<h2><a name="t_o_--time" id="t_o_--time">-t o --time</a></h2>
<div class="level2">

<p>

Se si vogliono tenere d&#039;occhio le prestazioni del proprio script, si può utilizzare questo flag da linea di comando, flag che farà in modo che l&#039;interprete stami a fine esecuzione il tempo che è stato impiegato dallo script (escludendo il tempo di parsing e di inizializzazione), opportunamente formattato in nanosecondi, millisecondi, ecc.
</p>

</div>
<!-- SECTION "-t o --time" [3121-3490] -->
<h2><a name="s_o_--trace" id="s_o_--trace">-s o --trace</a></h2>
<div class="level2">

<p>

Questo parametro abilita il reporting tracciato degli errori. 
Spesso accade che uno script diventa talmente grande da rendere difficile il debugging, soprattutto se l’inteprete genera errori sommari che non ci spiegano a fondo che cosa è successo e perchè è stato rilevato un errore.
Questo parametro ci aiuta in questo senso poichè, se attivato, istruirà l’interprete sulla generazione dettagliata degli errori, vediamo prima l’esempio di un errore senza che il flag sia attivato :

</p>
<pre class="code">hybris error.hy</pre>

<p>

darà l’output :

</p>
<pre class="code">Syntax error on line 17 : ‘undeclared_variable’ undeclared identifier .</pre>

<p>

mentre il comando :

</p>
<pre class="code">hybris error.hy --trace</pre>

<p>

Risulterà in :

</p>
<pre class="code">Syntax error on line 17 : ‘undeclared_variable’ undeclared identifier .</pre>
<pre class="code">Call Stack [memory usage 224 bytes] :
  do_error( n=123 )
     lulz( )</pre>

<p>

Come vedete, oltre a segnalare riga e natura dell’errore, hybris in modalità trace segnalerà anche le varie funzioni chiamate fino al punto in cui si è verificato l’errore stesso.
</p>

<p>
C’è un ulteriore nota da fare per quanto concerne questa modalità. 
Nel caso in cui lo script avesse un errore talmente grave da generare un Segmentation Fault (segnale SIGSEGV), hybris intercetterà l’evento e attiverà in automatico il reporting completo dell’errore, aggiungendo anche i dati relativi le variabili presenti nello stack virtuale del software.
</p>

</div>
<!-- SECTION "-s o --trace" [3491-] --></div><!-- closes <div class="dokuwiki export">-->